{
  
    
        "post0": {
            "title": "My reminder on Jupyter NoteBook",
            "content": "Commands . Command Execute . Double click or [ENTER] | Enter a cell | . [CTRL]+[ENTER] | Execute the contents of a text or code cell and exit | . [ESC] | Exit from a cell without executing it | . | | . [B] | Insert a cell below | . [A] | Insert a cell above (Above) | . [d]+[d] | Delete a cell without confirmation | . | | . [Y] | Transform cell to code cell Python | . [M] | Transform cell to text Markdown | . | | . [S] | Save | . [Cttl-S] | Save | . Formatting . Command Execute . # Title1 | Level 1 Title | . ###### Title6 | Level 6 title | . | | . ** ** | Insert bold | . * * | Insert italic | . ~~ ~~ | Insert barred | . Backslash | Prevents Markdown from interpreting a character | . [ENTER] | Create a paragraph by inserting a new line | . A line . Ordered list 1. . Element1 | Element2 | Non ordered list - . Element1 | Element2 | . Tasks -[ ] . [x] completed task | [ ] unrealized task | .",
            "url": "https://cecilegallioz.github.io/blog/jupyter/2021/04/16/ReminderJupyter.html",
            "relUrl": "/jupyter/2021/04/16/ReminderJupyter.html",
            "date": " • Apr 16, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "My reminder on Python",
            "content": "Useful informations . Variables are not typed, while objects are. | . Variables address objects (strong typing). | . Variable names are best in camelCase (first letter in lower case and no numbers in first) and as meaningful as possible. | . In Python to identify a block of instructions, you need an identation of 4 spaces and not a tab | . Small immutable objects are sometimes stored as singletons (only one possible occurrence) | . Basic functions . Function Description Type argument(s) Output . help() | Help on a function | Function name | String | . type() | Type of a variable | All | Type | . len() | Length | All | Int | . print() | Print to screen | All | Exit screen | . input(&quot;Question Text&quot;) | Retrieves value entered by user | String | All | . Types of data . Type Example Immutable? Singleton? Notes . Integer | 1 | Immutable | Possible | No loss of accuracy | . Boolean | True or False | Immutable | Possible | No loss of accuracy | . Float | 1.2 | Immutable | Possible | Possible loss of accuracy | . Complex | 1+2j | Immutable | Possible | Possible loss of accuracy | . String | &quot;blah&quot; or &#39;blah&#39; | Immutable | Possible | | . Tuple | ( ,) or ( , ,) or , | Immutable | Possible | | . | | | | | . List | [ , ] | Mutable | | Stores only the references | . Dictionary | { : , : } | Mutable | | Unordered and unchangeable keys/values | . Set | { , } | Mutable | | Unordered and unique immutable keys | . Operators . Operator Name Notes . = | Opérateur d&#39;affectation | | | | . # | Comments | | | | . | | | | | . + | Addition or concatenation | Int + Int = Int | Int + Float = Float | Text + Text = Text | . - | Subtraction | Int - Int = Int | Int - Float = Float | | . * | Multiplication | Int * Int = Int | Int * Float = Float | | . / | Division | Int / Int = Float | Int / Float = Float | | . | | | | | . % | Modulo | Subtract from division | | | . // | Whole division | Rounded down | | | . ** | Power | idem pow(a,b) | | | . abs() | Absolute value | | | | . | | | | | . str() | Cast in String | str(Int) = String | | | . int() | Cast in Int | int(Float) = Int | | | . float() | Cast in Float | float(Int) = Float | | | . | | | | | . += | Simultaneous addition and affection | | | | . Logic operators . Sign Description . == | equal to | . != | different | . &lt; | strictly less than | . &lt;= | lower than or equal to | . | | . not() | not | . and or &amp; | and | . or or &#39;pipe&#39; | or | . ^ | or exlusive | . | | . element in myGroup | is the element in my group | . Strings (immutable) . Method Description Argument(s) Output . objectString.upper() | All capitalized | - | Text | . objectString.capitalize() | First letter uppercase, subsequent letters lowercase | - | Text | . objectString.strip() | Removes spaces before and after the string | - | Text | . objectString.replace(&quot;old&quot;, &quot;new&quot;) | Replaces all occurrences of old with new | Text, Text | Text | . objectString.find(&quot;look&quot;) | Returns the position of the first occurrence of the searched word or -1 | Text | Int | . | | | | . objectString.strip(&#39;,&#39;).split(&#39;,&#39;) | Split put each word in a list according to a fixed character (&quot;,&quot;) and thanks to strip the last &quot;,&quot; will be deleted | - | List | . &quot;,&quot;.join([&#39;abc&#39;, &#39;def&#39;]) | Makes a string from a list according to a fixed character (e.g. here &quot;,&quot;) | - | Text | . f string . f&quot;blah-blah-blah {function1(variable1)} blah-blah-blah {function2(variable2)} blah-blah-blah&quot; . age = 45 name = &quot;Paul&quot; gap = 10 . f&quot;In {gap} year(s), {name} will be {age + gap} year(s) old.&quot; . &#39;In 10 year(s), Paul will be 55 year(s) old.&#39; . List (mutable) . nameList = [&quot;String&quot;, number, otherList, variable] . The list does not store the objects but only the reference to the object. Its size will not vary according to the size of the referenced objects. . The index starts at 0. . Unlike text, they are modified by their methods =&gt; they are mutable. . Use Method Description . Index | myList[1] | Accesses the 2nd element of the list | . | myList[-1] | Go to the last element of the list | . | myList[1:3] | Accesses the 2nd and 3rd elements of the list | . | myList.index(element) | Returns the index of the element | . | | | . Classic | print(myList) | Displays the entire list | . | len(myList) | Returns the length of a list | . | | | . Sorting | myList.sort() | Changes myList into a sorted list instead | . | sorted(myList) | Copy and sort myList | . | | | . Add | myList.append(element) | Adds the element to the end of the list | . | myList.insert(index, element) | Add the element to the specified index and move the following elements by one index | . | myList.extend([otherList]) | Add the list otherList to the end of the first one (myList) | . | | | . Remove | myList.pop(index) | Delete and display the element with the index as argument or the last one | . | maListe.remove(element) | Deletes the first occurrence of an element | . | del myList[index] | Deletes the element at the specified index | . | | | . String | &quot; &quot;.join(myList) | Transforms a list into a string according to the &quot; &quot;, the opposite of split() | . | | | . Random | random.choice(myList) | choose an element from the list | . | random.choices(myList,3) | choose 3 elements in the list with throw-in | . | random.sample(myList,3) | choose 3 elements from the list without throw-in | . myList = [8, 5, 12, 4, 45, 7] . myList[1] = 5 sum(myList) = 81 max(myList) = 45 . myList = list(range(2)) . myList = [0, 1] . myList.append(2) . myList = [0, 1, 2] . myList.insert(1,&quot;one half&quot;) . myList = [0, &#39;one half&#39;, 1, 2] . myList = [3, 5, 7, 6, 4, 1, 0, 2] myList.sort() . myList = [0, 1, 2, 3, 4, 5, 6, 7] . Tuple (immutable) . (element,) or element, =&gt; tuple singleton (element, element) or (element, element,) &lt;= for writing long tuples on several lines or element, element or element, element, =&gt; multiple tuple . These are sequence objects. . They have the same properties as lists except that they are immutable =&gt; once created they cannot be modified. . (a, b) = [3, 4] . a = 3 b = 4 . a, b = b, a . a = 4 b = 3 . e = list(range(10)) # tuple unpacking : cut a list # with the * we indicate that the length is unknown # with the _ or &quot;ignored&quot; we indicate that we are not interested in the content of this variable x, *_, y = e . x = 0 y = 9 . a = [1, 2] b = [3, 4] z = zip(a,b) [i for i in z] . [(1, 3), (2, 4)] . Dictionarie (mutable - immutable keys) . myDictionary = {key1:value1, key2:value2} . age = {&quot;eve&quot;:30, &quot;ana&quot;:25, &quot;bob&quot;:35} listeTupleAge = [(&quot;hel&quot;,21), (&quot;jon&quot;,41)] dicoAge = dict(listeTupleAge) age.update(dicoAge) . {&#39;eve&#39;: 30, &#39;ana&#39;: 25, &#39;bob&#39;: 35, &#39;hel&#39;: 21, &#39;jon&#39;: 41} . age[&#39;eve&#39;] . 30 . age.keys() # the result is a view . dict_keys([&#39;eve&#39;, &#39;ana&#39;, &#39;bob&#39;, &#39;hel&#39;, &#39;jon&#39;]) . age.values() # the result is a view . dict_values([30, 25, 35, 21, 41]) . for name,year in age.items(): print(f&quot;{name.capitalize()} is {year} years old&quot;) . Eve is 30 years old Ana is 25 years old Bob is 35 years old Hel is 21 years old Jon is 41 years old . Set (mutable - unordered) . {key1, key2} . A set is essentially a hash table. Close to dictionaries, mutable, unordered, they store only unique keys and are optimized for membership testing. . a = [1, 2, 1, 20, 1] s = set(a) . {1, 2, 20} . s.add(10) . {1, 2, 10, 20} . s.update([1, 3, 30]) . {1, 2, 3, 10, 20, 30} . s.discard(30) . {1, 2, 3, 10, 20} . 30 in s . False . If . if condition: block of instructions elif condition: block of instructions else: block of instructions . In conditional expression . Variable = valueTrue if test else valueFalse . In a test : . - False : False, 0, None, [], {}, (), &quot;&quot; - True : everything else . userName = &quot;C&quot; if len(userName)==1: print(&quot;Hello single!&quot;) elif len(userName)&gt;0: print(&quot;Hello&quot;, userName) else: print(&quot;Hello World!&quot;) . Hello single! . y = &quot;Hello single!&quot; if (len(userName) == 1) else &quot;Hello World!&quot; print(y) . Hello single! . Range(n) . range(*start, end + 1, *step) range(0, 5, 1) idem range(0,5) idem range(5) =&gt; 0, 1, 2, 3, 4 . x = range(2, 7, 2) for n in x: print(n) . 2 4 6 . For . for element in myGroup: instructions for i in range(start, end + 1, step): instructions . With the continue keyword, you can indicate that you want to go directly to the next element of the loop. With the keyword break, we interrupt the loop. . myList = [0, 3, 7, 13] for element in myList: print(element) . 0 3 7 13 . myText = &quot;World&quot; for element in myText: print(element) . W o r l d . While . while condition: instructions continue # ignore the following statements for this iteration break # exit while while True: # infinite loop instructions break . a = list(range(1,7)) print(a) while a: a.pop() if len(a) == 5: continue # ignore les instructions suivantes pour cette itération print(a) . [1, 2, 3, 4, 5, 6] [1, 2, 3, 4] [1, 2, 3] [1, 2] [1] [] . Functions . def functionName(arguments): &quot;&quot;&quot; documentation on several lines &quot;&quot;&quot; instructions (with or without return or just pass) . Document well if the function modifies the parameter passed to it . def calculPerimetreTriangle (cote1, cote2, cote3): &quot;&quot;&quot; receives three side lengths and returns the sum of the three &quot;&quot;&quot; perimetre = cote1 + cote2 + cote3 return perimetre print(calculPerimetreTriangle(1,2,3)) . 6 . You can put an optional argument with default value (not a mutable object) . def functionName(argument1, argument2, argument3=defaultvalue3): instructions . def f(a, b=10): print(a, b) f(1) f(1, 2) . 1 10 1 2 . Tuple or dictionaries in arguments . To not have to specify the number of elements sent to the function: . #Tuple def f(*t): print(t) #dictionary def f(**d): print(d) . def f(*t): print(t) f(1) f(1, 2, 3) . (1,) (1, 2, 3) . def f(a, b): print(a, b) L = [1, 2] f(*L) . 1 2 . def f(**d): print(d) f(nom=&quot;Dupond&quot;, prenom=&quot;Paul&quot;) . {&#39;nom&#39;: &#39;Dupond&#39;, &#39;prenom&#39;: &#39;Paul&#39;} . Named arguments . When you call the function, you can pass the arguments in the order you want, if you name them: . functionName(nonArgument2=valueArgument2, nameArgument1=valueArgument1) . . Warning: In the function call, it is not possible to enter a positional argument after an argument named . def f(a, b): print(&quot;a =&quot;, a,&quot;b =&quot;, b) f(b=1, a=5) # but f(1, 5) # warning #f(b=1, 5) =&gt; SyntaxError: positional argument follows keyword argument . a = 5 b = 1 a = 1 b = 5 . Order of consumption of arguments . The 4 forms of arguments will be summarized, depending on how the arguments of the function have been written and how they are called : . all &quot;normal&quot; arguments, called positional | form *args which catches in a tuple the rest of the positional arguments | named arguments name=&lt;value&gt; | form **dargs which catches in a dictionary the remainder of the named arguments | def foo(positionalArg1, namedArg2=100, *tuplePositionalArg, **dictNamedArg): print(f&quot;positionalArg1={positionalArg1}, namedArg2={namedArg2}, *tuplePositionalArg={tuplePositionalArg}, **dictNamedArg={dictNamedArg}&quot;) . foo(1) . positionalArg1=1, namedArg2=100, *tuplePositionalArg=(), **dictNamedArg={} . foo(1, 2) . positionalArg1=1, namedArg2=2, *tuplePositionalArg=(), **dictNamedArg={} . foo(1, 2, 3) . positionalArg1=1, namedArg2=2, *tuplePositionalArg=(3,), **dictNamedArg={} . foo(1, 2, 3, 4, arg5=5, arg6=6) . positionalArg1=1, namedArg2=2, *tuplePositionalArg=(3, 4), **dictNamedArg={&#39;arg5&#39;: 5, &#39;arg6&#39;: 6} . def bar(positionalArg1, *tuplePositionalArg, namedArg2=100, **dictNamedArg): print(f&quot;positionalArg1={positionalArg1}, namedArg2={namedArg2}, *tuplePositionalArg={tuplePositionalArg}, **dictNamedArg={dictNamedArg}&quot;) . bar(1) . positionalArg1=1, namedArg2=100, *tuplePositionalArg=(), **dictNamedArg={} . bar(1, 2) . positionalArg1=1, namedArg2=100, *tuplePositionalArg=(2,), **dictNamedArg={} . bar(1, 2, namedArg2=3) . positionalArg1=1, namedArg2=3, *tuplePositionalArg=(2,), **dictNamedArg={} . bar(1, 2, 3, namedArg2=4, namedArg5=5) . positionalArg1=1, namedArg2=4, *tuplePositionalArg=(2, 3), **dictNamedArg={&#39;namedArg5&#39;: 5} . Lambda functions . Functions that we do not intend to reuse . lambda x: [function of x] . You can execute a lambda function on a list of arguments (x) with a map and see the results in a list with a list: . list(map(lambda x: [function of x], [list of x])) . and filter the results with a filter: . list(filter(lambda x: [test on [function of x]], [list of x])) . list(map(lambda x: x**2, range(10))) . [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] . list(filter(lambda x: x % 2 == 0, range(10))) . [0, 2, 4, 6, 8] . list(map(lambda x: x**2, filter(lambda x: x % 2 == 0, range(10)))) . [0, 4, 16, 36, 64] . List comprehensions = For on lists . We create a list, set or dictionary according to our needs. . on l a list . comprehesion_l = [ function(i) for i in l if test(i) ] . on s a set . comprehesion_s = { function(i) for i in s if test(i) } . on d a dictionary . comprehesion_d = { function(i): j for i,j in d.items() if test(i, j) } . a = [1, 4, 6, 9, 13] b = [i**2 for i in a] . b . [1, 16, 36, 81, 169] . name = [&#39;Alice&#39;, &#39;evE&#39;, &#39;sonia&#39;, &#39;BOB&#39;] name = [p.title() for p in name] . print(name) . [&#39;Alice&#39;, &#39;Eve&#39;, &#39;Sonia&#39;, &#39;Bob&#39;] . Funny cases . Mistrust on the floats . 0.3 - 0.1 . 0.19999999999999998 . 0.3 - 0.1 == 0.2 . False . from decimal import Decimal Decimal(&#39;0.3&#39;) - Decimal(&#39;0.1&#39;) == Decimal(&#39;0.2&#39;) . True . from fractions import Fraction Fraction(3, 10) - Fraction(1, 10) == Fraction(2, 10) . True .",
            "url": "https://cecilegallioz.github.io/blog/python/2021/04/15/ReminderPython.html",
            "relUrl": "/python/2021/04/15/ReminderPython.html",
            "date": " • Apr 15, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "My sources",
            "content": "What I’m using in my journey ? . Logo Source . | Deep Learning for Coders with Fastai and Pytorch: AI Applications Without a PhD, authors : Howard, J. and Gugger, S., publisher O’Reilly Media, Incorporated | . | Kaggle/Courses | . | Python 3 : des fondamentaux aux concepts avancés du langage | . | Démarrez votre projet avec Python | .",
            "url": "https://cecilegallioz.github.io/blog/general/2021/04/14/Sources.html",
            "relUrl": "/general/2021/04/14/Sources.html",
            "date": " • Apr 14, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "My name is Cécile Gallioz, I live in France with my husband and son. . After 15 years in business intelligence and requirements gathering, I am adding a string to my bow with Python development. . My goal is to develop tools to improve productivity and efficiency. . My values are creativity, transmission and integrity. . I have a master’s degree in mathematical engineering and a bachelor’s degree in computer development. . My profile on Kaggle . My profile on LinkedIn . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://cecilegallioz.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://cecilegallioz.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}